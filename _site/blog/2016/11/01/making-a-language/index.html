<!DOCTYPE html>
<html lang="en">
<head>


<meta charset="UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Brian Mock">
<meta name="description" content="How to make a programming language from scratch in JS">
<meta name="theme-color" content="#e8fdf5">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@wavebeem">
<meta name="twitter:creator" content="@wavebeem">
<meta name="og:title" content="Making a Language">
<meta name="og:description" content="How to make a programming language from scratch in JS">
<meta name="og:image" content="https://mockbrian.com/brian.png">

<title>Making a Language</title>

<link rel="stylesheet" media="screen" href="/tachyons.min.css?t=1563254458666645000">
<link rel="stylesheet" media="screen" href="/style.css?t=1563254458666645000">

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  (function(host) {
    var ids = {
      "dev.mockbrian.com": "UA-52704502-2",
      "mockbrian.com": "UA-52704502-1",
    };
    if (host in ids) {
      ga("create", ids[host], "auto");
      ga("send", "pageview");
    }
  }(window.location.host));
</script>

</head>
<body class="flex flex-column min-vh-100 bg-washed-green lh-copy helvetica">

<div class="flex-auto">





<!-- Small nav -->
<div class="dn-ns">
  <nav class="f3 flex flex-column mb4 bb dark-pink bw1 b--black-10">
    <a class="pa3 hover-bg-white-40 hover-bottomline link color-inherit pv2 ph3 flex-auto hover-outline b" href="/">Brian Mock</a>
    <a class="pa3 hover-bg-white-40 hover-bottomline link color-inherit pv2 ph3 flex-auto hover-outline" href="/">Home</a>
    <a class="pa3 hover-bg-white-40 hover-bottomline link color-inherit pv2 ph3 flex-auto hover-outline" href="/blog">Blog</a>
    <a class="pa3 hover-bg-white-40 hover-bottomline link color-inherit pv2 ph3 flex-auto hover-outline" href="/resume">Resume</a>
  </nav>
</div>

<!-- Big nav -->
<div class="dn db-ns">
  <nav class="f3 flex mb4 items-center bb dark-pink bw1 b--black-10">
    <a class="pa3 hover-bg-white-40 hover-bottomline link color-inherit b" href="/">Brian Mock</a>
    <a class="pa3 hover-bg-white-40 hover-bottomline link color-inherit" href="/">Home</a>
    <a class="pa3 hover-bg-white-40 hover-bottomline link color-inherit" href="/blog">Blog</a>
    <a class="pa3 hover-bg-white-40 hover-bottomline link color-inherit" href="/resume">Resume</a>
  </nav>
</div>


<main class="ph4-ns ph3 center flex-auto lh-copy Content">
  <h1 class="ma0 f1-ns f2 lh-title">
    <a href="#">Making a Language</a>
  </h1>
  <p class="ma0 helvetica">November 1, 2016</p>

  <h2>What&#39;s in a programming language?</h2>

<p>Programming language implementations vary wildly, but the steps are roughly as follows:</p>

<ul>
<li>Parse source code text into abstract syntax tree (AST) such as JSON</li>
<li><em>(Optional)</em> Static analysis of AST to report warnings and errors</li>
<li>Depending on whether you want a compiler or an interpreter:

<ul>
<li>Compile to executable, bytecode, JS, etc. <strong>OR</strong></li>
<li>Evaluate the AST to run the program</li>
</ul></li>
</ul>

<p><strong>Note:</strong> Regexps are not powerful enough to for the job here. Don&#39;t believe me? Check out the <a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">Chomsky hierarchy</a> on Wikipedia, or this funny <a href="http://stackoverflow.com/a/1732454">StackOverflow answer</a> about parsing HTML.</p>

<h2>Starting out easy</h2>

<p>One of the smallest programming languages I could choose to implement is <a href="https://github.com/wavebeem/duckweed">Lambda Calculus</a>, but it&#39;s pretty hard to see how that relates to everyday programming. So I&#39;ll be walking through a tiny Lisp I made called <a href="https://github.com/wavebeem/duckweed">Duckweed</a>. It&#39;s about 300 lines, so it shouldn&#39;t be too bad to get through!</p>

<p>In the interest of space, I will not be diving into a full explanation of how <a href="https://github.com/jneen/parsimmon">Parsimmon</a> works. You should check out the repo for more information, or just read this post anyway.</p>

<h2>What is Duckweed?</h2>

<p>A lot of people get scared at the idea of Lisp because they hear it&#39;s a &quot;hacker language&quot; or some other gatekeeping nonsense. The short of it is, Lisp is just a style of programming language with very simple and regular syntax, perfect for a short example like this blog post.</p>

<p>Some Lisp languages have many features, but Duckweed intentionally has very few. In terms of JavaScript, Duckweed has operations similar to <code>function</code>, <code>call()</code>, <code>var</code>, <code>+</code>, <code>*</code>, <code>-</code>, <code>if</code>, and not really much of anything else.</p>

<p>Here&#39;s the <a href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program">hello world</a> program in Duckweed:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="s">"hello world"</span><span class="p">)</span><span class="w">
</span></code></pre></div>
<p>Now let&#39;s cover a basic <a href="https://en.wikipedia.org/wiki/Factorial">factorial</a> program in JavaScript.</p>

<p>In math factorial can be defined as follows:</p>
<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">factorial</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div>
<p>In English, when <code>factorial</code> is given 0, it returns 1. When factorial is given any other number (n), it returns <code>n * factorial(n - 1)</code>. In JavaScript, this looks like the following:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">factorial</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
</code></pre></div>
<p>Duckweed doesn&#39;t have the concept of a function declaration, just anonymous functions, so the Duckweed program is a little closer to this JavaScript program:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">factorial</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">factorial</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">factorial</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
</code></pre></div>
<p>In Duckweed, <code>let</code> is the word for <code>var</code>, and it takes an expression at the end to evaluate. Also <code>lambda</code> is the word for <code>function</code>.</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">factorial</span><span class="w"> </span><span class="p">(</span><span class="nf">lambda</span><span class="w"> </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
        </span><span class="mi">1</span><span class="w">
        </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">(</span><span class="nf">factorial</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="mi">1</span><span class="p">)))))))</span><span class="w">
  </span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="p">(</span><span class="nf">factorial</span><span class="w"> </span><span class="mi">4</span><span class="p">)))</span><span class="w">
</span></code></pre></div>
<p>So that&#39;s what Duckweed looks like, and you can see it&#39;s capable of doing at least basic math.</p>

<h2>First things first</h2>

<p>Let&#39;s start off with the top level of Duckweed: <code>main.js</code>.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'fs'</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">util</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'util'</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">parse</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./parse'</span><span class="p">).</span><span class="nx">parse</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">evaluate</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./evaluate'</span><span class="p">).</span><span class="nx">evaluate</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">globals</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./globals'</span><span class="p">).</span><span class="nx">globals</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">Scope</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./scope'</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">U</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./util'</span><span class="p">);</span>
</code></pre></div>
<p>First up we have a lot of things to import. Not much to see here.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">process</span><span class="p">.</span><span class="nx">argv</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">filename</span> <span class="o">=</span> <span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="kr">const</span> <span class="nx">code</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span> <span class="s1">'utf-8'</span><span class="p">);</span>

<span class="kr">const</span> <span class="nx">opts</span> <span class="o">=</span> <span class="p">{</span><span class="na">colors</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">depth</span><span class="p">:</span> <span class="kc">null</span><span class="p">};</span>
<span class="kd">function</span> <span class="nx">show</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">util</span><span class="p">.</span><span class="nx">inspect</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">opts</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<p>Next we read the Duckweed code from the file specified on the command line, and define a helper function to pretty-print objects. This will be useful for inspecting the data generated by the parser.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">parse</span><span class="p">(</span><span class="nx">code</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">ast</span> <span class="o">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
  <span class="c1">// show(ast);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">U</span><span class="p">.</span><span class="nx">showSexp</span><span class="p">(</span><span class="nx">ast</span><span class="p">));</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">();</span>
  <span class="kr">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">evaluate</span><span class="p">(</span><span class="nx">globals</span><span class="p">,</span> <span class="nx">ast</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">U</span><span class="p">.</span><span class="nx">showSexp</span><span class="p">(</span><span class="nx">x</span><span class="p">));</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s1">'parse error!'</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>This is where the magic happens. It all really boils down to <code>parse</code> and <code>evaluate</code>, but we&#39;ve got some extra code in here to show parse errors and inspect the code being evaluated.</p>

<h2>Parsing all those parentheses</h2>

<p>One of the reasons Lisp is a good choice is that the syntax is <em>very</em> simple to parse compared to most other languages.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">P</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'parsimmon'</span><span class="p">);</span>

<span class="kr">const</span> <span class="nx">Comment</span> <span class="o">=</span>
  <span class="nx">P</span><span class="p">.</span><span class="nx">regex</span><span class="p">(</span><span class="sr">/;</span><span class="se">[^\n]</span><span class="sr">*/</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">skip</span><span class="p">(</span><span class="nx">P</span><span class="p">.</span><span class="nx">alt</span><span class="p">(</span><span class="nx">P</span><span class="p">.</span><span class="nx">string</span><span class="p">(</span><span class="s1">'\n'</span><span class="p">),</span> <span class="nx">P</span><span class="p">.</span><span class="nx">eof</span><span class="p">))</span>
    <span class="p">.</span><span class="nx">desc</span><span class="p">(</span><span class="s1">'a comment'</span><span class="p">);</span>

<span class="kr">const</span> <span class="nx">_</span> <span class="o">=</span>
  <span class="nx">P</span><span class="p">.</span><span class="nx">alt</span><span class="p">(</span><span class="nx">P</span><span class="p">.</span><span class="nx">whitespace</span><span class="p">,</span> <span class="nx">Comment</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">many</span><span class="p">()</span>
    <span class="p">.</span><span class="nx">desc</span><span class="p">(</span><span class="s1">'whitespace'</span><span class="p">);</span>
</code></pre></div>
<p>We start off by describing what comments look like (semicolon until the end of line), and what whitespace looks like.</p>

<p>Everything in Lisp is an <a href="https://en.wikipedia.org/wiki/S-expression">S-expression</a> (sexp for short). In our very simple Lisp, this just means it&#39;s either a list or an &quot;atom&quot;, which is the Lisp word for something very basic, like numbers and strings.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">SExp</span> <span class="o">=</span>
  <span class="nx">P</span><span class="p">.</span><span class="nx">lazy</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">P</span><span class="p">.</span><span class="nx">alt</span><span class="p">(</span><span class="nx">AList</span><span class="p">,</span> <span class="nx">Atom</span><span class="p">));</span>
</code></pre></div>
<p>A list is simply an open parenthesis followed by zero or more sexps and terminated by a closing parenthesis. We tag this information inside an object with <code>type: &quot;List&quot;</code> so that later we can easily inspect the things we parsed.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">AList</span> <span class="o">=</span>
  <span class="nx">P</span><span class="p">.</span><span class="nx">string</span><span class="p">(</span><span class="s1">'('</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">_</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">SExp</span><span class="p">).</span><span class="nx">skip</span><span class="p">(</span><span class="nx">_</span><span class="p">).</span><span class="nx">many</span><span class="p">())</span>
    <span class="p">.</span><span class="nx">skip</span><span class="p">(</span><span class="nx">P</span><span class="p">.</span><span class="nx">string</span><span class="p">(</span><span class="s1">')'</span><span class="p">))</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">items</span> <span class="o">=&gt;</span> <span class="p">({</span><span class="na">type</span><span class="p">:</span> <span class="s1">'List'</span><span class="p">,</span> <span class="nx">items</span><span class="p">}))</span>
    <span class="p">.</span><span class="nx">desc</span><span class="p">(</span><span class="s1">'a list'</span><span class="p">);</span>
</code></pre></div>
<p>For the purpose of brevity, Duckweed strings do not have any escape characters (e.g. <code>&quot;\n&quot;</code>).</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">AString</span> <span class="o">=</span>
  <span class="nx">P</span><span class="p">.</span><span class="nx">string</span><span class="p">(</span><span class="s1">'"'</span><span class="p">)</span>
    <span class="c1">// TODO: Accept escaped characters</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">P</span><span class="p">.</span><span class="nx">regex</span><span class="p">(</span><span class="sr">/</span><span class="se">[^</span><span class="sr">"</span><span class="se">]</span><span class="sr">*/</span><span class="p">))</span>
    <span class="p">.</span><span class="nx">skip</span><span class="p">(</span><span class="nx">P</span><span class="p">.</span><span class="nx">string</span><span class="p">(</span><span class="s1">'"'</span><span class="p">))</span>
    <span class="c1">// TODO: Convert escaped characters back</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">value</span> <span class="o">=&gt;</span> <span class="p">({</span><span class="na">type</span><span class="p">:</span> <span class="s1">'String'</span><span class="p">,</span> <span class="nx">value</span><span class="p">}))</span>
    <span class="p">.</span><span class="nx">desc</span><span class="p">(</span><span class="s1">'a string'</span><span class="p">);</span>
</code></pre></div>
<p>It&#39;s traditional in Lisp to just write <code>#t</code> for true and <code>#f</code> for false.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">True</span> <span class="o">=</span>
  <span class="nx">P</span><span class="p">.</span><span class="nx">string</span><span class="p">(</span><span class="s1">'#t'</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">result</span><span class="p">({</span><span class="na">type</span><span class="p">:</span> <span class="s1">'True'</span><span class="p">})</span>
    <span class="p">.</span><span class="nx">desc</span><span class="p">(</span><span class="s1">'#t'</span><span class="p">);</span>

<span class="kr">const</span> <span class="nx">False</span> <span class="o">=</span>
  <span class="nx">P</span><span class="p">.</span><span class="nx">string</span><span class="p">(</span><span class="s1">'#f'</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">result</span><span class="p">({</span><span class="na">type</span><span class="p">:</span> <span class="s1">'False'</span><span class="p">})</span>
    <span class="p">.</span><span class="nx">desc</span><span class="p">(</span><span class="s1">'#f'</span><span class="p">);</span>
</code></pre></div>
<p>Numbers are numbers. We pass them through the JavaScript <code>Number</code> function to convert them from strings.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">ANumber</span> <span class="o">=</span>
  <span class="nx">P</span><span class="p">.</span><span class="nx">regex</span><span class="p">(</span><span class="sr">/-</span><span class="se">?[</span><span class="sr">0-9</span><span class="se">]</span><span class="sr">+/</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">value</span> <span class="o">=&gt;</span> <span class="p">({</span><span class="na">type</span><span class="p">:</span> <span class="s1">'Number'</span><span class="p">,</span> <span class="nx">value</span><span class="p">}))</span>
    <span class="p">.</span><span class="nx">desc</span><span class="p">(</span><span class="s1">'a number'</span><span class="p">);</span>
</code></pre></div>
<p>Symbols are plain words in your code that usually represent variables, but can also represent keywords (such as <code>if</code>).</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">ASymbol</span> <span class="o">=</span>
  <span class="nx">P</span><span class="p">.</span><span class="nx">regex</span><span class="p">(</span><span class="sr">/</span><span class="se">[</span><span class="sr">a-zA-Z_+*=&lt;&gt;?</span><span class="se">\/</span><span class="sr">-</span><span class="se">]</span><span class="sr">+/</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">name</span> <span class="o">=&gt;</span> <span class="p">({</span><span class="na">type</span><span class="p">:</span> <span class="s1">'Symbol'</span><span class="p">,</span> <span class="nx">name</span><span class="p">}))</span>
    <span class="p">.</span><span class="nx">desc</span><span class="p">(</span><span class="s1">'a symbol'</span><span class="p">);</span>
</code></pre></div>
<p>Any Lisp would be remiss without this shorthand for choosing not to evaluate a sexp. Basically you just prefix any code with <code>&#39;</code> and Lisp treats it as data instead.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">Quote</span> <span class="o">=</span>
  <span class="nx">P</span><span class="p">.</span><span class="nx">string</span><span class="p">(</span><span class="s1">'\''</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">skip</span><span class="p">(</span><span class="nx">_</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">SExp</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">sexp</span> <span class="o">=&gt;</span> <span class="p">({</span>
      <span class="na">type</span><span class="p">:</span> <span class="s1">'List'</span><span class="p">,</span>
      <span class="na">items</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="s1">'Symbol'</span><span class="p">,</span> <span class="na">name</span><span class="p">:</span> <span class="s1">'quote'</span><span class="p">},</span>
        <span class="nx">sexp</span>
      <span class="p">]</span>
    <span class="p">}));</span>
</code></pre></div>
<p>Like I said earlier, an atom is just any of the basic non-list data types. And a &quot;file&quot; is just a single sexp with optional whitespace around it. Most Lisps accept zero or more sexps at the top level of a file, but we&#39;re keeping it simple here.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">Atom</span> <span class="o">=</span>
  <span class="nx">P</span><span class="p">.</span><span class="nx">alt</span><span class="p">(</span>
    <span class="nx">Quote</span><span class="p">,</span>
    <span class="nx">AString</span><span class="p">,</span>
    <span class="nx">ANumber</span><span class="p">,</span>
    <span class="nx">True</span><span class="p">,</span>
    <span class="nx">False</span><span class="p">,</span>
    <span class="nx">ASymbol</span>
  <span class="p">);</span>

<span class="kr">const</span> <span class="nx">File</span> <span class="o">=</span>
  <span class="nx">_</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">SExp</span><span class="p">).</span><span class="nx">skip</span><span class="p">(</span><span class="nx">_</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">parse</span><span class="p">(</span><span class="nx">code</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">File</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">code</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">exports</span><span class="p">.</span><span class="nx">parse</span> <span class="o">=</span> <span class="nx">parse</span><span class="p">;</span>
</code></pre></div>
<h2>Scope</h2>

<p>Variable scope is one of the most important things to model in a programming language, so we&#39;ll go over that first.</p>

<p>I used <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data types</a> for my implementation. Basically there are two kinds of scope: empty and non-empty. We start off with an empty scope and every scope after that is non-empty. A non-empty scope just contains a JavaScript object mapping the variable names to their values.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">Empty</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'Scope.Empty'</span><span class="p">];</span>
</code></pre></div>
<p>This is an empty scope. We just have an array with a string tag so we know which kind it is. Then we use the <code>create</code> function to wrap a scope with another scope. This is how we create non-empty scopes.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">create</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="s1">'Scope.Nonempty'</span><span class="p">,</span> <span class="nx">items</span><span class="p">,</span> <span class="nx">parent</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div>
<p>Again we have a string tag at the beginning to identify which case (empty vs non-empty), but in this case we also have an object containing the values in the current scope, and a reference to the parent scope so we can traverse the scope hierarchy.</p>

<p>A simple scope chain could look like this:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">s1</span> <span class="o">=</span> <span class="nx">Scope</span><span class="p">.</span><span class="nx">Empty</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">s2</span> <span class="o">=</span> <span class="nx">Scope</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">});</span>
<span class="kr">const</span> <span class="nx">s3</span> <span class="o">=</span> <span class="nx">Scope</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">s2</span><span class="p">,</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="mi">3</span><span class="p">});</span>
</code></pre></div>
<p>And thus from the scope <code>s3</code> we could see variables <code>a</code> and <code>b</code>, but <code>a</code> would have the value <code>3</code> from scope <code>s3</code>&#39;s perspective since it is <a href="https://en.wikipedia.org/wiki/Variable_shadowing">shadowing</a> <code>s2</code>&#39;s variable <code>a</code>.</p>

<p>Now that we have creation, we need a way to look up variables by their names. It&#39;s a little unwieldy to manually dig through nested scopes, so we make a <a href="https://en.wikipedia.org/wiki/Recursion_(computer_science)">recursive</a> function to help out.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">lookup</span><span class="p">(</span><span class="nx">scope</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">scope</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="s1">'Scope.Empty'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'no such variable '</span> <span class="o">+</span> <span class="nx">key</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">scope</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!==</span> <span class="s1">'Scope.Nonempty'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'not a valid scope'</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">scope</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">scope</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="nx">key</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">lookup</span><span class="p">(</span><span class="nx">scope</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nx">key</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>It&#39;s a little cryptic accessing the pieces of a scope since I put them in an array, but remember that the first element is the tag. Basically for empty scopes we throw an error, then non-empty scopes check to see if the scope contains the variable, and if not, call <code>lookup</code> recursively on the parent scope.</p>

<p>So using the scopes <code>s1</code>, <code>s2</code>, and <code>s3</code> from above, we can use <code>lookup</code> function like this:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">lookup</span><span class="p">(</span><span class="nx">s3</span><span class="p">,</span> <span class="s2">"a"</span><span class="p">);</span> <span class="c1">// Returns 3</span>
<span class="nx">lookup</span><span class="p">(</span><span class="nx">s2</span><span class="p">,</span> <span class="s2">"a"</span><span class="p">);</span> <span class="c1">// Returns 1</span>
<span class="nx">lookup</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="s2">"a"</span><span class="p">);</span> <span class="c1">// Throws an error</span>
</code></pre></div>
<p>This might seem like enough to model scope, but you also need to be able to update the values in an existing scope. We&#39;re not exposing this in the language through reassignment, but it&#39;s still important for modeling variable scope.</p>

<p>For the purposes of Duckweed it&#39;s sufficient to just update the current scope without going up the chain, but languages with more complicated assignment rules we need to take extra care in this functionality.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">assign</span><span class="p">(</span><span class="nx">scope</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">scope</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="s1">'Scope.Nonempty'</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">scope</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'not a valid scope to assign to'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">exports</span><span class="p">.</span><span class="nx">assign</span> <span class="o">=</span> <span class="nx">assign</span><span class="p">;</span>
<span class="nx">exports</span><span class="p">.</span><span class="nx">lookup</span> <span class="o">=</span> <span class="nx">lookup</span><span class="p">;</span>
<span class="nx">exports</span><span class="p">.</span><span class="nx">create</span> <span class="o">=</span> <span class="nx">create</span><span class="p">;</span>
<span class="nx">exports</span><span class="p">.</span><span class="nx">Empty</span> <span class="o">=</span> <span class="nx">Empty</span><span class="p">;</span>
</code></pre></div>
<h2>Evaluation</h2>

<p>Most evaluation is straightforward in Duckweed: data is just data. Numbers are just numbers, strings are just strings, true and false are exactly what they sound like. But the way you evaluate lists is where the complication happens.</p>

<p>So here&#39;s the overview of the evaluation file, with the complicated bits taken out for now:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">Scope</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./scope'</span><span class="p">);</span>

<span class="kr">const</span> <span class="nx">special</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="kr">const</span> <span class="nx">table</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">List</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">},</span>
  <span class="nx">JSFunction</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
  <span class="p">},</span>
  <span class="nx">True</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
  <span class="p">},</span>
  <span class="nx">False</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
  <span class="p">},</span>
  <span class="nb">String</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
  <span class="p">},</span>
  <span class="nb">Number</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">node</span><span class="p">;</span>
  <span class="p">},</span>
  <span class="nx">Symbol</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Scope</span><span class="p">.</span><span class="nx">lookup</span><span class="p">(</span><span class="nx">scope</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">EVAL</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">table</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">type</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">table</span><span class="p">[</span><span class="nx">node</span><span class="p">.</span><span class="nx">type</span><span class="p">](</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">node</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'cannot evaluate '</span> <span class="o">+</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">node</span><span class="p">));</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">evaluate</span><span class="p">(</span><span class="nx">scope</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">EVAL</span><span class="p">([],</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">exports</span><span class="p">.</span><span class="nx">EVAL</span> <span class="o">=</span> <span class="nx">EVAL</span><span class="p">;</span>
<span class="nx">exports</span><span class="p">.</span><span class="nx">evaluate</span> <span class="o">=</span> <span class="nx">evaluate</span><span class="p">;</span>
</code></pre></div>
<p>So to evaluate a symbol you look it up in the variable scope, and everything else is just passed through as raw data.</p>

<h2>List eval</h2>

<p>Now here&#39;s the list evaluation function.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">List</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">first</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="c1">// Evaluate special form such as `if` or `lambda`</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">first</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">'Symbol'</span> <span class="o">&amp;&amp;</span> <span class="nx">special</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">first</span><span class="p">.</span><span class="nx">name</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">special</span><span class="p">[</span><span class="nx">first</span><span class="p">.</span><span class="nx">name</span><span class="p">](</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">node</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// Regular function call</span>
  <span class="kr">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">EVAL</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">first</span><span class="p">);</span>
  <span class="c1">// but first, let's make sure we're right here!</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">type</span> <span class="o">!==</span> <span class="s1">'JSFunction'</span> <span class="o">&amp;&amp;</span> <span class="nx">f</span><span class="p">.</span><span class="nx">type</span> <span class="o">!==</span> <span class="s1">'Function'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'cannot call non-function'</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kr">const</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">node</span>
    <span class="p">.</span><span class="nx">items</span>
    <span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">EVAL</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">x</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">'JSFunction'</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">args2</span> <span class="o">=</span> <span class="p">[</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">args</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">f</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">args2</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">'Function'</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">newStack</span> <span class="o">=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">concat</span><span class="p">([</span><span class="s1">'#&lt;lambda&gt;'</span><span class="p">]);</span>
    <span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">parameters</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">p</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">obj</span><span class="p">[</span><span class="nx">p</span><span class="p">.</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">args</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="p">});</span>
    <span class="kr">const</span> <span class="nx">newScope</span> <span class="o">=</span> <span class="nx">Scope</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">scope</span><span class="p">,</span> <span class="nx">obj</span><span class="p">);</span>
    <span class="kr">const</span> <span class="nx">values</span> <span class="o">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">EVAL</span><span class="p">(</span><span class="nx">newScope</span><span class="p">,</span> <span class="nx">newScope</span><span class="p">,</span> <span class="nx">x</span><span class="p">));</span>
    <span class="k">return</span> <span class="nx">values</span><span class="p">[</span><span class="nx">values</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">},</span>
</code></pre></div>
<p>There are three cases here, and we try to deal with them as early as possible:</p>

<ol>
<li>The symbol is a special form, not a function call (such as <code>if</code>).</li>
<li>The symbol references a native JavaScript function.</li>
<li>The symbol references a function created inside Duckweed.</li>
</ol>

<p>So for the first case we just dispatch to a table with the unevaluated list data. Note that <em>all</em> list evaluations pass through the current call stack and the current variable scope.</p>

<h2>Special eval</h2>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">quote</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Should be called like (quote foo) with exactly one argument.</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'bad quote syntax'</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">},</span>
</code></pre></div>
<p>The Lisp concept of quoting just means &quot;please don&#39;t evaluate me&quot;, so this is the most simple special form. It just returns the unevaluated data. It can be used like <code>(eval (quote a))</code> which is equivalent to simply <code>a</code>.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">list</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">items</span> <span class="o">=</span>
    <span class="nx">node</span>
      <span class="p">.</span><span class="nx">items</span>
      <span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">EVAL</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">x</span><span class="p">));</span>
  <span class="k">return</span> <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="s1">'List'</span><span class="p">,</span> <span class="nx">items</span><span class="p">};</span>
<span class="p">},</span>
</code></pre></div>
<p>To make a list, we just evaluate the arguments and put them into a list data structure. You can use it like <code>(list 1 2 (+ a b) 4)</code>.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">lambda</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">parameters</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="kr">const</span> <span class="nx">body</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="na">type</span><span class="p">:</span> <span class="s1">'Function'</span><span class="p">,</span>
    <span class="nx">scope</span><span class="p">,</span>
    <span class="nx">parameters</span><span class="p">,</span>
    <span class="nx">body</span>
  <span class="p">};</span>
<span class="p">},</span>
</code></pre></div>
<p>The critical part of <code>lambda</code> is that we store a reference to the current scope on the function object. If you&#39;re familiar with the concept of <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">closure</a>, this is required to implement that.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="k">if</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">condition</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="kr">const</span> <span class="nx">trueBranch</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="kr">const</span> <span class="nx">falseBranch</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="c1">// The key to `if` is to only evaluate the right branch, not both of them.</span>
  <span class="kr">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">EVAL</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">condition</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="s1">'False'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">EVAL</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">falseBranch</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">EVAL</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">trueBranch</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">},</span>
</code></pre></div>
<p>Basically with <code>if</code> you choose the false branch of the value is false, otherwise the true branch. And you only evaluate at most one branch.</p>

<p>The most complicated special form is <code>let</code>. Basically we have to create a new scope and one-by-one evaluate and assign variables inside it, then evaluate the body of the <code>let</code> expression.</p>

<p>Example:</p>
<div class="highlight"><pre><code class="language-clojure" data-lang="clojure"><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">((</span><span class="nf">a</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">b</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span><span class="w">
  </span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="p">))</span><span class="w">
</span></code></pre></div>
<p>It&#39;s important that the scope grows as we evaluate <code>a</code> and <code>b</code> in order, and then we evaluate <code>(print a b)</code>, throw it away, then evaluate and return <code>(+ a b)</code>.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// We need to actually mutate the scope as we evaluate let-bindings so that</span>
  <span class="c1">// recursive functions can see themselves.</span>
  <span class="kr">const</span> <span class="nx">pairs</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="kr">const</span> <span class="nx">newScope</span> <span class="o">=</span> <span class="nx">Scope</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">scope</span><span class="p">,</span> <span class="p">{});</span>
  <span class="nx">pairs</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">p</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">name</span><span class="p">;</span>
    <span class="kr">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">EVAL</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">newScope</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="nx">Scope</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">newScope</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
  <span class="p">});</span>
  <span class="c1">// Evaluate one or more expressions after the let-bindings and return the</span>
  <span class="c1">// last one. Useful for side effects.</span>
  <span class="kr">const</span> <span class="nx">values</span> <span class="o">=</span>
    <span class="nx">node</span>
      <span class="p">.</span><span class="nx">items</span>
      <span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
      <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">EVAL</span><span class="p">(</span><span class="nx">scope</span><span class="p">,</span> <span class="nx">newScope</span><span class="p">,</span> <span class="nx">x</span><span class="p">));</span>
  <span class="k">return</span> <span class="nx">values</span><span class="p">[</span><span class="nx">values</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div>
<h2>Global built-ins</h2>

<p>We have all the core operations at this point, but usually programming languages don&#39;t ask you to implement basic math, numbers, and printing yourself, so we&#39;ll provide that from JavaScript via some globals in the evaluator.</p>

<p>Just a few simple imports.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">Scope</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./scope'</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">U</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./util'</span><span class="p">)</span>
<span class="kr">const</span> <span class="nx">E</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./evaluate'</span><span class="p">);</span>
</code></pre></div>
<p>The basic boolean constants we expect to see in any language.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">TRUE</span> <span class="o">=</span> <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="s1">'True'</span><span class="p">};</span>
<span class="kr">const</span> <span class="nx">FALSE</span> <span class="o">=</span> <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="s1">'False'</span><span class="p">};</span>
</code></pre></div>
<p>Numbers are pretty basic too.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">NUMBER</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="s1">'Number'</span><span class="p">,</span> <span class="nx">value</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div>
<p>You might notice a pattern at this point: &quot;basic&quot; values are usually represented in an evaluator as a <code>type</code> field and a <code>value</code> field if necessary.</p>

<p>This printing function isn&#39;t a whole lot of fun, so just check out <code>util.js</code> yourself if you want to.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">print</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">U</span><span class="p">.</span><span class="nx">showSexp</span><span class="p">(</span><span class="nx">x</span><span class="p">));</span>
  <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>We just need to reach inside the wrapped numbers and then re-wrap them, reusing JavaScript&#39;s operators to accomplish the basic math.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">NUMBER</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">value</span> <span class="o">+</span> <span class="nx">b</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">subtract</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">NUMBER</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">value</span> <span class="o">-</span> <span class="nx">b</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">multiply</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">NUMBER</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">value</span> <span class="o">*</span> <span class="nx">b</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">lessThan</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nx">value</span> <span class="o">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">value</span> <span class="p">?</span> <span class="nx">TRUE</span> <span class="p">:</span> <span class="nx">FALSE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Ideally these math functions should add to the stack also, but it&#39;s not strictly necessary for the evaluator to work. It just would make a stack trace nicer if the program crashed.</p>

<p><code>eval</code> is just using the <code>EVAL</code> function we built-up earlier! We&#39;re just exposing it for the code to use.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">evaluate</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">sexp</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">E</span><span class="p">.</span><span class="nx">EVAL</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">sexp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Now we make the actual top level scope the evaluator will user later.</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">api</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">print</span><span class="p">,</span>
  <span class="s1">'+'</span><span class="p">:</span> <span class="nx">add</span><span class="p">,</span>
  <span class="s1">'-'</span><span class="p">:</span> <span class="nx">subtract</span><span class="p">,</span>
  <span class="s1">'*'</span><span class="p">:</span> <span class="nx">multiply</span><span class="p">,</span>
  <span class="s1">'&lt;'</span><span class="p">:</span> <span class="nx">lessThan</span><span class="p">,</span>
  <span class="na">eval</span><span class="p">:</span> <span class="nx">evaluate</span>
<span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">api</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">k</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">api</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="s1">'JSFunction'</span><span class="p">,</span> <span class="na">f</span><span class="p">:</span> <span class="nx">api</span><span class="p">[</span><span class="nx">k</span><span class="p">]}</span>
<span class="p">});</span>

<span class="kr">const</span> <span class="nx">globals</span> <span class="o">=</span> <span class="nx">Scope</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">Scope</span><span class="p">.</span><span class="nx">Empty</span><span class="p">,</span> <span class="nx">api</span><span class="p">);</span>

<span class="nx">exports</span><span class="p">.</span><span class="nx">globals</span> <span class="o">=</span> <span class="nx">globals</span><span class="p">;</span>
</code></pre></div>
<h2>Wrapping up</h2>

<p>This covers basically everything about the <a href="https://github.com/wavebeem/duckweed">Duckweed</a> language and evaluator. Check out the repo for the full code. Once you understand that, check out my other language <a href="https://github.com/wavebeem/hibiscus">Hibiscus</a> for a (slightly larger) example of a small JS-like language.</p>


  <div class="helvetica f3 mv4">
    <a
      class="ba bw1 br2 dark-pink db pv2 ph3 hover-bg-white-40 no-underline"
      href="/blog"
    >
      &lsaquo; Read other posts
    </a>
  </div>
</main>

<script type="module">
  // I would prefer to generate links for my h2 and h3 elements at build time,
  // but I can't figure out a good way to make Jekyll do that, sadly
  function slug(text) {
    return text
      .trim()
      .toLowerCase()
      .replace(/\'/gi, "")
      .replace(/[^a-z0-9]/gi, "-")
      .replace(/-{2,}/g, "-")
      .replace(/^-+|-+$/gm, "")
      .substring(0, 64);
  }

  for (const h of document.querySelectorAll("h2, h3")) {
    h.id = h.id || slug(h.textContent);
    h.innerHTML = "<a href='#" + h.id + "'>" + h.innerHTML + "</a>";
  }
</script>


</div>

<footer class="black-70 tc helvetica ph3 pv3 bt bw1 b--black-10 f4">
  &copy; 2019 Brian Mock
</footer>


</body>
</html>
